AWSTemplateFormatVersion: '2010-09-09'
Description: >
  CloudFormation template for the Photo Album application infrastructure
  as per Homework Assignment 3, Point 7. Creates two Lambda functions,
  an API Gateway, a frontend S3 bucket (publicly hosted), and a
  photo storage S3 bucket.

Parameters:
  FrontendBucketName:
    Type: String
    Description: Name for the S3 bucket to host the frontend website. Must be globally unique.
    Default: cloud-hw3-fe-002
  PhotosBucketName:
    Type: String
    Description: Name for the S3 bucket to store photos. Must be globally unique.
    Default: cloud-hw3-photos-002

Resources:
  # --- S3 Buckets ---
  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref FrontendBucketName
      AccessControl: PublicRead # Required for website hosting
      WebsiteConfiguration:
        IndexDocument: index.html # Assuming index.html is the entry point
      PublicAccessBlockConfiguration: # Explicitly allow public access for website hosting
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
              - '*'
            AllowedMethods:
              - GET
              - PUT # Needed for uploading via API Gateway SDK
              - HEAD
            AllowedOrigins:
              - '*' # Be more restrictive in production
            ExposedHeaders:
              - ETag
              - x-amz-meta-customLabels # Expose custom header
            MaxAge: 3000

  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Statement:
          - Sid: PublicReadGetObject
            Effect: Allow
            Principal: '*'
            Action: s3:GetObject
            Resource: !Sub arn:aws:s3:::${FrontendBucket}/*

  PhotosBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref PhotosBucketName
      AccessControl: Private # Photos should generally be private
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      CorsConfiguration: # CORS for allowing PUTs from API Gateway/Frontend
        CorsRules:
          - AllowedHeaders:
              - '*'
            AllowedMethods:
              - PUT
              - HEAD
            AllowedOrigins:
              - '*' # Be more restrictive in production, maybe allow origin of API Gateway?
            MaxAge: 3000

  # --- IAM Roles ---
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: PhotoAppLambdaExecutionRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole # Logs access
      Policies:
        - PolicyName: PhotoAppLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow # Allow access to the photos S3 bucket 
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:HeadObject # Needed for retrieving metadata 
                Resource: !Sub arn:aws:s3:::${PhotosBucket}/*
              - Effect: Allow # Allow Rekognition access 
                Action:
                  - rekognition:DetectLabels
                Resource: '*' # Rekognition actions don't support resource-level permissions
              - Effect: Allow # Allow Lex access (for search lambda) 
                Action:
                  - lex:PostText
                Resource: '*' # Specify Lex bot ARN if known
              # Add ElasticSearch permissions here if it were included

  ApiGatewayS3Role: # Role for API Gateway to PUT objects into the Photos S3 Bucket 
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ApiGatewayS3PutPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub arn:aws:s3:::${PhotosBucket}/*

  # --- Lambda Functions ---
  IndexPhotosFunction: # LF1 
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: index-photos
      Handler: index.lambda_handler # Replace with your handler e.g., index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9 # Choose your runtime
      Timeout: 30
      # Hardcoded sample code - replace with actual code or S3 source 
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          s3 = boto3.client('s3')
          rekognition = boto3.client('rekognition')
          # elasticsearch = boto3.client('es') # Import if ES were included

          # photos_es_endpoint = os.environ['ES_ENDPOINT'] # Get from env if ES included

          def lambda_handler(event, context):
              print("Received event: " + json.dumps(event, indent=2))

              # Get the bucket name and key for the new object
              bucket = event['Records'][0]['s3']['bucket']['name']
              key = event['Records'][0]['s3']['object']['key']

              try:
                  # 1. Detect labels using Rekognition
                  rek_response = rekognition.detect_labels(
                      Image={'S3Object': {'Bucket': bucket, 'Name': key}},
                      MaxLabels=10
                  )
                  labels = [label['Name'].lower() for label in rek_response['Labels']]
                  print(f"Rekognition labels: {labels}")

                  # 2. Get custom labels from S3 metadata
                  custom_labels = []
                  try:
                      head_response = s3.head_object(Bucket=bucket, Key=key)
                      print(f"Head response: {head_response}")
                      if 'Metadata' in head_response and 'x-amz-meta-customlabels' in head_response['Metadata']:
                          custom_labels_str = head_response['Metadata']['x-amz-meta-customlabels']
                          custom_labels = [label.strip().lower() for label in custom_labels_str.split(',')]
                          print(f"Custom labels: {custom_labels}")
                  except Exception as e:
                      print(f"Error getting head object or custom labels: {e}")


                  # Combine labels
                  all_labels = list(set(labels + custom_labels)) # Use set for uniqueness

                  # 3. Prepare JSON for ElasticSearch 
                  es_doc = {
                      'objectKey': key,
                      'bucket': bucket,
                      'createdTimestamp': head_response['LastModified'].isoformat(), # Use actual timestamp
                      'labels': all_labels
                  }
                  print(f"Document for ES: {json.dumps(es_doc)}")

                  # 4. Index document in ElasticSearch (Commented out as ES is not required by point 7) 
                  # Implement ES indexing here if needed
                  # print("Skipping ES indexing as per requirement.")

                  return {
                      'statusCode': 200,
                      'body': json.dumps('Indexing complete (ES skipped)!')
                  }

              except Exception as e:
                  print(e)
                  print(f'Error processing object {key} from bucket {bucket}.')
                  raise e

  SearchPhotosFunction: # LF2 
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: search-photos
      Handler: search.lambda_handler # Replace with your handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9 # Choose your runtime
      Timeout: 30
      # Hardcoded sample code - replace with actual code or S3 source 
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          lex = boto3.client('lex-runtime')
          # elasticsearch = boto3.client('es') # Import if ES were included

          # photos_es_endpoint = os.environ['ES_ENDPOINT'] # Get from env if ES included
          # lex_bot_name = os.environ['LEX_BOT_NAME'] # Get from env
          # lex_bot_alias = os.environ['LEX_BOT_ALIAS'] # Get from env

          def lambda_handler(event, context):
              print("Received event: " + json.dumps(event, indent=2))

              query = event.get('queryStringParameters', {}).get('q')

              if not query:
                  return {
                      'statusCode': 400,
                      'headers': { 'Access-Control-Allow-Origin': '*' },
                      'body': json.dumps('Missing query parameter "q"')
                  }

              try:
                  # 1. Disambiguate using Lex 
                  # Replace with actual bot details
                  lex_response = lex.post_text(
                      botName='YourLexBotName',      # Replace
                      botAlias='YourLexBotAlias',    # Replace
                      userId='search-lambda-user', # Can be anything unique per user session
                      inputText=query
                  )
                  print(f"Lex response: {lex_response}")

                  keywords = []
                  if lex_response.get('intentName') == 'SearchIntent' and lex_response.get('slots'):
                      # Assuming slots are named like 'keywordOne', 'keywordTwo', etc.
                      # Adapt this logic based on your actual Lex bot slot configuration
                      for slot_name, slot_value in lex_response['slots'].items():
                          if slot_value:
                              keywords.append(slot_value.lower())
                  print(f"Keywords from Lex: {keywords}")

                  results = []
                  if keywords:
                      # 2. Search ElasticSearch (Commented out as ES is not required by point 7)
                      # Implement ES search logic here using keywords
                      print(f"Skipping ES search for keywords: {keywords} as per requirement.")
                      # Dummy results for demonstration if needed
                      # results = [ { 'url': f'https://s3.amazonaws.com/{os.environ["PHOTOS_BUCKET"]}/photo1.jpg', 'labels': keywords } ]
                  else:
                      print("No keywords identified by Lex or Lex intent not matched.")
                      # Return empty array as per spec 

                  return {
                      'statusCode': 200,
                      'headers': {
                          'Access-Control-Allow-Origin': '*', # Enable CORS
                          'Content-Type': 'application/json'
                      },
                      'body': json.dumps({'results': results})
                  }

              except Exception as e:
                  print(e)
                  print(f'Error processing search query "{query}".')
                  return {
                      'statusCode': 500,
                      'headers': { 'Access-Control-Allow-Origin': '*' },
                      'body': json.dumps(f'Internal server error: {e}')
                  }

  # --- Lambda Permissions & Triggers ---
  PhotosBucketPermission: # Allow S3 to invoke the IndexPhotos Lambda
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt IndexPhotosFunction.Arn
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceArn: !GetAtt PhotosBucket.Arn
      SourceAccount: !Ref AWS::AccountId

  PhotosBucketNotification: # Configure the S3 PUT trigger
    Type: AWS::S3::BucketNotificationConfiguration
    DependsOn: PhotosBucketPermission # Ensure permission is granted first
    Properties:
      Bucket: !Ref PhotosBucket
      LambdaFunctionConfigurations:
        - Event: s3:ObjectCreated:Put
          Function: !GetAtt IndexPhotosFunction.Arn

  # --- API Gateway --- 
  PhotoApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: PhotoAlbumApi
      Description: API for Photo Album application
      EndpointConfiguration:
        Types: [REGIONAL]

  # /search resource
  SearchResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref PhotoApi
      ParentId: !GetAtt PhotoApi.RootResourceId
      PathPart: search

  SearchGetMethod: # GET /search?q={query text}
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref PhotoApi
      ResourceId: !Ref SearchResource
      HttpMethod: GET
      AuthorizationType: NONE # Change if auth is needed, e.g., API Key 
      Integration:
        Type: AWS_PROXY # Lambda Proxy integration
        IntegrationHttpMethod: POST # Lambda proxy uses POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SearchPhotosFunction.Arn}/invocations
        Credentials: !GetAtt ApiGatewayLambdaInvokeRole.Arn # Role to invoke Lambda
        RequestParameters:
          integration.request.querystring.q: method.request.querystring.q
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'" # CORS
      RequestParameters:
        method.request.querystring.q: true # Mark 'q' as required
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: Empty
          ResponseParameters:
             method.response.header.Access-Control-Allow-Origin: true # CORS

  # /photos resource
  PhotosResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref PhotoApi
      ParentId: !GetAtt PhotoApi.RootResourceId
      PathPart: '{object}' # Use path parameter for the photo name

  PhotosPutMethod: # PUT /photos/{object}
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref PhotoApi
      ResourceId: !Ref PhotosResource
      HttpMethod: PUT
      AuthorizationType: NONE # Change if auth is needed 
      RequestParameters:
        method.request.path.object: true
        method.request.header.Content-Type: true
        method.request.header.x-amz-meta-customLabels: false # Custom labels header
      Integration:
        Type: AWS # S3 Proxy Integration 
        IntegrationHttpMethod: PUT
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:s3:path/${PhotosBucket}/{object}
        Credentials: !GetAtt ApiGatewayS3Role.Arn # Role for S3 access
        RequestParameters:
          integration.request.path.object: method.request.path.object
          integration.request.header.Content-Type: method.request.header.Content-Type
          integration.request.header.x-amz-meta-customLabels: method.request.header.x-amz-meta-customLabels # Map custom header 
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'" # CORS Headers
              method.response.header.Access-Control-Allow-Methods: "'OPTIONS,PUT,GET'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,x-amz-meta-customLabels'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true


  # OPTIONS method for CORS preflight requests on /photos/{object}
  PhotosOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref PhotoApi
      ResourceId: !Ref PhotosResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,x-amz-meta-customLabels'" # Allow custom header
              method.response.header.Access-Control-Allow-Methods: "'PUT,OPTIONS'" # Allow PUT
              method.response.header.Access-Control-Allow-Origin: "'*'" # Allow all origins (restrict in production)
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: Empty
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true


  # OPTIONS method for CORS preflight requests on /search
  SearchOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref PhotoApi
      ResourceId: !Ref SearchResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'" # Allow GET
              method.response.header.Access-Control-Allow-Origin: "'*'" # Allow all origins (restrict in production)
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: Empty
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true


  # Role for API Gateway to invoke Lambda
  ApiGatewayLambdaInvokeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ApiGatewayInvokeLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: !GetAtt SearchPhotosFunction.Arn # Allow invoking only the search function

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: # Ensure methods are created before deployment
      - SearchGetMethod
      - PhotosPutMethod
      - PhotosOptionsMethod
      - SearchOptionsMethod
    Properties:
      RestApiId: !Ref PhotoApi
      StageName: prod # Deploy to a stage named 'prod'

Outputs:
  FrontendBucketWebsiteURL:
    Description: URL for the frontend website hosted on S3
    Value: !GetAtt FrontendBucket.WebsiteURL
    Export:
      Name: !Sub "${AWS::StackName}-FrontendURL"
  PhotosBucketNameOutput:
    Description: Name of the S3 bucket storing photos
    Value: !Ref PhotosBucket
    Export:
      Name: !Sub "${AWS::StackName}-PhotosBucketName"
  ApiGatewayInvokeURL:
    Description: Invoke URL for the API Gateway stage
    Value: !Sub "https://${PhotoApi}.execute-api.${AWS::Region}.amazonaws.com/prod"
    Export:
      Name: !Sub "${AWS::StackName}-ApiInvokeUrl"